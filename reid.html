<html>

<head>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }

        .state {
            fill: lightgrey;
        }

        .outline {
            fill: none;
            stroke: black;
            stroke-width: 1px;
        }

        .graticule {
            fill: none;
            stroke: grey;
            stroke-width: 1px;
        }

        .axis path,
        .axis line {
            fill: none;
            shape-rendering: crispEdges;
        }

        .axis text {
            font-size: 12px;
        }

        .line {
            fill: none;
            stroke: steelblue;
            stroke-width: 1.5px;
            opacity: 0.5;
        }

        .tooltip {
            opacity: 0;
            position: absolute;
            background-color: white;
            border: solid 1px;
            padding: 10px;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>

<body>

    <h1>Happiness v.s. Weather Variables in the US</h1>
    <p>
        These first set of graphs show the happiness values of various cities in the US, with larger circles indicating
        greater happiness. The circles are placed over a map which shows the average weather variables for each county
        in the US.
        We want to visualize whether certain weather variables correlate with the happiness of a region.
    </p>

    <h3>Happiness v.s. Average Daily Sunlight</h3>
    <svg id="sunlight_map" height=500 width=800></svg>
    <svg id="sunlight_map_legend" height="100" width="600"
        style="background: #fff; margin-top:30px; padding-bottom:50px"></svg>

    <h3>Happiness v.s. Average Daily Temperature</h3>
    <svg id="temp_map" height=500 width=800></svg>
    <svg id="temp_map_legend" height="100" width="600"
        style="background: #fff; margin-top:30px; padding-bottom:50px"></svg>

    <h3>Happiness v.s. Average Daily Precipitation</h3>
    <svg id="precip_map" height=500 width=800></svg>
    <svg id="precip_map_legend" height="100" width="600"
        style="background: #fff; margin-top:30px; padding-bottom:50px"></svg>

    <script>
        const requestData = async function () {
            let countiesDataset = await d3.json("counties-10m.json");
            console.log(countiesDataset);

            const countyWeatherData = await d3.csv("county_weather_data.csv");
            console.log(countyWeatherData);

            var countyDict = {}   // countyID ===> countyData
            countyWeatherData.forEach(d => {
                countyDict[d["County Code"]] = d;
            });
            console.log(countyDict)

            const data = await d3.csv("happiness.csv", d3.autoType);
            console.log(data);

            makeMap("sunlight_map", "Avg Daily Sunlight (KJ/m)", "#sunlight_map_legend", "Average Daily Sunlight (KJ/m²)")
            makeMap("temp_map", "Avg Temp", "#temp_map_legend", "Avg Daily Temp (°F)")
            makeMap("precip_map", "Avg Daily Precipitation (in)", "#precip_map_legend", "Avg Daily Precipitation (in)")

            function makeMap(select, weatherVar, legendSelect, legendText) {
                const svg = d3.select(`svg#${select}`);
                const width = svg.attr('width');
                const height = svg.attr('height');
                const margins = { top: 20, right: 20, bottom: 20, left: 20 };
                const mapWidth = width - margins.left - margins.right;
                const mapHeight = height - margins.top - margins.bottom;

                let mapArea = svg.append('g')
                    .attr('transform', `translate(${margins.left},${margins.top})`);

                // 2b. Pick out topographic features and build d3 helpers
                var counties = topojson.feature(countiesDataset, countiesDataset.objects.counties);     // List of state outlines to fill
                var countiesMesh = topojson.mesh(countiesDataset, countiesDataset.objects.counties);    // 'Mesh' of all outlines put together for a stroke
                var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], counties);
                var path = d3.geoPath().projection(projection);
                console.log(counties);
                console.log(countiesMesh);

                // 2d. Add a graticule (we did this after 2c, but it must go here)
                //      (Graticules are much more configurable, but we'll use the default for now)
                let graticule = d3.geoGraticule10();
                mapArea.append("path").attr("class", "graticule").attr("d", path(graticule));

                // 2c. Draw states and outlines (see CSS at the top)
                let statePaths = mapArea.selectAll("path.state").data(counties.features)
                    .join("path")
                    .attr("class", "state")
                    .attr("note", d => d.id)  // debugging
                    .attr("d", path)

                mapArea.append("path").datum(countiesMesh)
                    .attr("class", "outline")
                    .attr("d", path);

                const happinessExtent = d3.extent(data, d => d["happiness"]);
                const happinessScale = d3.scaleLinear().domain(happinessExtent)
                    .range([0, 15]);

                mapArea.selectAll("circle").data(data)
                    .join("circle")
                    .attr("cx", d => projection([d["longitude"], d["latitude"]])[0])
                    .attr("cy", d => projection([d["longitude"], d["latitude"]])[1])
                    .attr("r", d => happinessScale(d["happiness"]))
                    .style("fill", "black")
                    .style("stroke", "white")
                // .style("opacity", 0.7)


                // 3c. Make a d3 color scale for frequency    
                const weatherVarExtent = d3.extent(countyWeatherData, d => d[weatherVar]);
                console.log(weatherVarExtent);

                // This scale wasn't great because it crunched most of the points to the bottom 3rd of the color scale
                //  3 state outliers with high values mean it is very distorted
                // const colorScale = d3.scaleSequential(d3.interpolateGnBu).domain(minMax);

                // Next, we try quantize, which splits the domain into bins
                // In general, it splits it into as many bins as you provide items in the range

                // const colorScale = d3.scaleQuantize()   // ZZZZZZZZZZZ  zedzedzedzedzedzedzedzedzedzed
                //                      .domain(minMax)
                //                      .range(["#fff","#d1e8ed","#adc2da","#8879b3","#762b80"])

                // Finally, we use quantile, which looks at the points statistically
                //  It will give weird results if you send minMax to the .domain(). Why?
                //  ...because it needs to inspect *all of the values* in order to see the point *distribution*
                //  we use Object.values() here to get all of the values out of the stateCounts dictionary

                const weatherVarScale = d3.scaleQuantile()      // LLLLLLLLL  elelelelelelelelloelloeleolol
                    .domain(d3.map(countyWeatherData, d => d[weatherVar]))
                    // .range(["#fff", "#d1e8ed", "#adc2da", "#8879b3", "#762b80"]);
                    .range(["#fff", "#62a1db", "#e7d87d", "#dd9f40", "#b4451f", "#b01111"]);


                // //  If you want to use a log scale instead of a linear quantile (which might work better):
                // //   Here is one way to do this (note the use of Symlog because our domain includes 0)
                // //   We create a new function that feeds the data value into a Symlog scale programmed to return 0 to 1
                // //   It then routes the [0,1] value to interpolateGnBu, which returns a color, doing what we want
                // //   Just like with normal scales, you feed them a data value and get back a color/pixel
                // const colorScale = d => d3.interpolateGnBu( d3.scaleSymlog().domain(minMax).range([0,1])(d) );
                // colorScale.domain = () => minMax;  // Hack to get legend working again because it uses scale.domain()
                // // Another way to do this would be:
                // const colorScale = d3.scaleLog().domain(minMax).interpolate(d => d3.interpolateGnBu)
                // // Getting a scaleQuantile to work would be a bit trickier
                // // You'll want to think about how to adjust the domain of the scale (hint: d3.map to transform data)
                // //   and then also how you're going to show the values legend in the bottom scale


                // 3d. Recolor the states to make a choropleth map
                mapArea.selectAll(".state")
                    .style("fill", d => weatherVarScale(countyDict[d.id] === undefined ? 0 : countyDict[d.id][weatherVar]));

                // 3e. Use the extra legend code to draw a legend
                drawLegend(legendSelect, weatherVarScale, legendText);
            }


        }
        requestData();
    </script>

    <script>
        // Flexible legend-drawing function - Jeff Rzeszotarski, 2022
        //   Released under MIT Free license
        //  Takes in an SVG element selector <legendSelector> and a d3 color scale <legendColorScale>
        //
        // Usage example: drawLegend("#legendID", grossIncomeColorScale)
        function drawLegend(legendSelector, legendColorScale, legendText) {

            // This code should adapt to a variety of different kinds of color scales
            //  Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS

            // Shrink legend bar by 5 px inwards from sides of SVG
            const offsets = {
                width: 10,
                top: 2,
                bottom: 24
            };
            // Number of integer 'pixel steps' to draw when showing continuous scales
            //    Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
            const stepSize = 4;
            // Extend the minmax by 0% in either direction to expose more features by default
            const minMaxExtendPercent = 0;


            const legend = d3.select(legendSelector);
            const legendHeight = legend.attr("height");
            const legendBarWidth = legend.attr("width") - (offsets.width * 2);
            const legendMinMax = d3.extent(legendColorScale.domain());
            // recover the min and max values from most kinds of numeric scales
            const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
            const barHeight = legendHeight - offsets.top - offsets.bottom;

            // In this case the "data" are pixels, and we get numbers to use in colorScale
            // Use this to make axis labels
            let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
            legendMinMax[1] + minMaxExtension])
                .range([0, legendBarWidth]);
            let barAxis = d3.axisBottom(barScale);

            // Place for bar slices to live
            let bar = legend.append("g")
                .attr("class", "legend colorbar")
                .attr("transform", `translate(${offsets.width},${offsets.top})`)

            // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******

            // Check if we're using a binning scale - if so, we make blocks of color
            if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
                // Get the thresholds
                let thresholds = [];
                if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
                else { thresholds = legendColorScale.quantiles() }

                const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

                // Use the quantile breakpoints plus the min and max of the scale as tick values
                barAxis.tickValues(barThresholds);

                // Draw rectangles between the threshold segments
                for (let i = 0; i < barThresholds.length - 1; i++) {
                    let dataStart = barThresholds[i];
                    let dataEnd = barThresholds[i + 1];
                    let pixelStart = barAxis.scale()(dataStart);
                    let pixelEnd = barAxis.scale()(dataEnd);

                    bar.append("rect")
                        .attr("x", pixelStart)
                        .attr("y", 0)
                        .attr("width", pixelEnd - pixelStart)
                        .attr("height", barHeight)
                        .style("fill", legendColorScale((dataStart + dataEnd) / 2.0))
                        .style("stroke", "black");
                }
            }
            // Else if we have a continuous / roundable scale
            //  In an ideal world you might construct a custom gradient mapped to the scale
            //  For this one, we use a hack of making stepped rects
            else if (legendColorScale.hasOwnProperty('rangeRound')) {
                // NOTE: The barAxis may round min and max values to make them pretty
                // ** This also means there is a risk of the legend going beyond scale bounds
                // We need to use the barAxis min and max just to be sure the bar is complete
                //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
                // ** We also need to create patches for the scale if the labels exceed bounds
                //     (floating point comparisons risky for small data ranges,but not a big deal
                //      because patches will be indistinguishable from actual scale bottom)
                // It's likely that scale clamping will actually do this for us elegantly
                // ...but better to be safer and patch the regions anyways

                for (let i = 0; i < legendBarWidth; i = i + stepSize) {

                    let center = i + (stepSize / 2);
                    let dataCenter = barAxis.scale().invert(center);

                    // below normal scale bounds
                    if (dataCenter < legendMinMax[0]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[0]))
                            .style("stroke", "black");
                    }
                    // within normal scale bounds
                    else if (dataCenter < legendMinMax[1]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(dataCenter))
                            .style("stroke", "black");
                    }
                    // above normal scale bounds
                    else {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[1]))
                            .style("stroke", "black");
                    }

                }
            }
            // Otherwise we have a nominal scale
            else {
                let nomVals = legendColorScale.domain().sort();

                // Use a scaleBand to make blocks of color and simple labels
                let barScale = d3.scaleBand().domain(nomVals)
                    .range([0, legendBarWidth])
                    .padding(0.05);
                barAxis.scale(barScale);

                // Draw rectangles for each nominal entry
                nomVals.forEach(d => {
                    bar.append("rect")
                        .attr("x", barScale(d))
                        .attr("y", 0)
                        .attr("width", barScale.bandwidth())
                        .attr("height", barHeight)
                        .style("fill", legendColorScale(d))
                        .style("stroke", "black");
                });
            }
            // DONE w/SWITCH

            // Finally, draw legend labels
            legend.append("g")
                .attr("class", "legend axis")
                .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
                .call(barAxis);

            legend.append("text").text(legendText)
                .attr("transform", `translate(${legendBarWidth / 2 - 75},${120})`)
            // .style("text-align", "center")
            // .style("margin", "auto")

        }
    </script>

    <svg id="titleSvg" height=100 width=1000>
    </svg>
    <svg id="scatterplot" height=500 width=1000 style="margin-bottom: 50px;">
    </svg>
    <script>
        const titleSvg = d3.select('svg#titleSvg');
        titleSvg.append('text')
            .attr('x', 430)
            .attr('y', 40)
            .attr('text-anchor', 'middle')
            .style('font-size', '24px')
            .style('font-weight', 'bold')
            .text('Happiness vs Sunshine');

        // add the caption
        titleSvg.append('text')
            .attr('x', 530)
            .attr('y', 80)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .text(`Graph 1: Happiness of USA cities with respect to the average hours of 
                sunshine a city gets per day. Each circle represents a city in the USA, 
                sorted into regions by color.`);


        let colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        d3.csv("happiness.csv").then((data) => {
            data.forEach((d, i) => {
                d['happiness'] = Number(d['happiness']);
                d['sunshine_duration_mean'] = Number(d['sunshine_duration_mean']);
                d['precipitation_hours_mean'] = Number(d['precipitation_hours_mean']);
            });
            console.log(data);

            const svg = d3.select('svg#scatterplot');
            const width = svg.attr('width');
            const height = svg.attr('height');
            const margins = { top: 10, right: 220, bottom: 70, left: 70 };
            const chartWidth = width - margins.left - margins.right;
            const chartHeight = height - margins.top - margins.bottom;
            let chartArea = svg.append('g')
                .attr('transform', `translate(${margins.left},${margins.top})`);

            const sunshineExtent = d3.extent(data, d => d['sunshine_duration_mean']);
            const sunshineScale = d3.scaleLinear()
                .domain(sunshineExtent)
                .range([0, chartWidth]);

            const happinessExtent = d3.extent(data, d => d['happiness']);
            const happinessScale = d3.scaleLinear()
                .domain(happinessExtent)
                .range([chartHeight, 0]);

            // happiness on the y-axis
            let leftAxis = d3.axisLeft(happinessScale);
            svg.append('g')
                .attr('class', 'y axis')
                .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                .call(leftAxis);

            svg.append('text')
                .attr('class', 'left axis label')
                .attr('transform', `translate(${margins.left - 45},${chartHeight / 2 + margins.top + 20}) rotate(${-90})`)
                .text('Happiness');

            // sunshine on the x-axis
            let bottomAxis = d3.axisBottom(sunshineScale);
            svg.append('g')
                .attr('class', 'x axis')
                .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                .call(bottomAxis);


            svg.append('text')
                .attr('class', 'bottom axis label')
                .attr('transform', `translate(${chartWidth / 2 - margins.left + 15},${chartHeight + margins.top + 45})`)
                .text('Mean Sunshine Duration (Hours)');

            console.log("This is the y coordinate of the sunshine label: ");
            console.log(chartHeight + margins.top + 50);

            // left gridlines
            let leftGridlines = d3.axisLeft(happinessScale)
                .tickSize(-chartWidth - 10)
                .tickFormat('');
            svg.append('g')
                .attr('class', 'y gridlines')
                .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                .call(leftGridlines);

            // bottom gridlines
            let bottomGridlines = d3.axisBottom(sunshineScale)
                .tickSize(-chartHeight - 10)
                .tickFormat('');


            svg.append('g')
                .attr('class', 'x gridlines')
                .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                .call(bottomGridlines);

            // group points by region for background blobs
            const groupedData = d3.groups(data, d => d.region);
            console.log('grouped data: ');
            console.log(groupedData);

            // line generator to draw the path of the blobs and draw curves
            const lineGen = d3.line()
                .curve(d3.curveMonotoneX);

            // for each region, compute the convex hull and draw a path (blob)
            groupedData.forEach(([region, points]) => {
                const hull = d3.polygonHull(points.map(d => [sunshineScale(d['sunshine_duration_mean']), happinessScale(d['happiness'])]));

                console.log("hull");
                console.log(hull);
                if (hull) {
                    chartArea.append('path')
                        .attr('d', lineGen(hull))
                        .attr('fill', colorScale(region))
                        .attr('opacity', 0.2)  // make the blobs lighter than the circles
                        .attr('stroke', colorScale(region))
                        .attr('stroke-width', 1);
                }
            });

            // adding the points
            let circles = chartArea.selectAll("circle").data(data)
                .join("circle")
                .attr("r", 6)
                .attr('opacity', 0.4)
                .attr("fill", d => colorScale(d.region))  // color by region
                .attr("region", d => d.region)
                .attr("cx", d => sunshineScale(d['sunshine_duration_mean']))
                .attr("cy", d => happinessScale(d['happiness']));

            // creating the legend
            var legend = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${chartWidth + margins.left + 20}, ${margins.top})`);

            let regionsArr = ["West", "Midwest", "Southwest", "Southeast", "Northeast"];

            // creates the space for the rectangles in legend
            let rectSpaces = legend.selectAll(".legend-key")
                .data(regionsArr)
                .enter()
                .append('g')
                .attr('class', 'legend-key')
                .attr('transform', (elem, i) => `translate(0, ${i * 25})`);

            // Append rectangles to each legend entry
            rectSpaces.append('rect')
                .attr('height', 20)
                .attr('width', 20)
                .attr('opacity', 0.4)
                .attr('fill', d => colorScale(d));

            // Append text labels for each legend entry
            rectSpaces.append('text')
                .attr('x', 30)
                .attr('y', 15)
                .text(d => d);


            // make the points OVER the gridlines
            chartArea.raise();

        });
    </script>
    <svg id="titleSvg2" height=100 width=1000>
    </svg>
    <svg id="scatterplot2" height=500 width=1000 style="margin-bottom: 50px;">
    </svg>
    <script>

        titleSvg2 = d3.select('svg#titleSvg2');
        titleSvg2.append('text')
            .attr('x', 450)
            .attr('y', 40)
            .attr('text-anchor', 'middle')
            .style('font-size', '24px')
            .style('font-weight', 'bold')
            .text('Happiness vs Precipitation Duration');

        // add the caption
        titleSvg2.append('text')
            .attr('x', 390)
            .attr('y', 80)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .text(`Graph 2: Happiness of USA cities with respect to logarithmic average hours 
                of precipitation a city experiences per day.`);

        d3.csv("happiness.csv").then((data) => {
            data.forEach((d, i) => {
                d['happiness'] = Number(d['happiness']);
                d['sunshine_duration_mean'] = Number(d['sunshine_duration_mean']);
                d['precipitation_hours_mean'] = Number(d['precipitation_hours_mean']);
            });

            const svg = d3.select('svg#scatterplot2');
            const width = svg.attr('width');
            const height = svg.attr('height');
            const margins = { top: 10, right: 220, bottom: 70, left: 70 };
            const chartWidth = width - margins.left - margins.right;
            const chartHeight = height - margins.top - margins.bottom;
            let chartArea = svg.append('g')
                .attr('transform', `translate(${margins.left},${margins.top})`);

            const precipExtent = d3.extent(data, d => d['precipitation_hours_mean']);
            const precipScale = d3.scaleLog()
                .domain(precipExtent)
                .range([0, chartWidth]);


            console.log("precip extent: ");
            console.log(precipExtent);

            const happinessExtent = d3.extent(data, d => d['happiness']);
            const happinessScale = d3.scaleLinear()
                .domain(happinessExtent)
                .range([chartHeight, 0]);

            // happiness on the y-axis
            let leftAxis = d3.axisLeft(happinessScale);
            svg.append('g')
                .attr('class', 'y axis')
                .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                .call(leftAxis);

            svg.append('text')
                .attr('class', 'left axis label')
                .attr('transform', `translate(${margins.left - 45},${chartHeight / 2 + margins.top + 20}) rotate(${-90})`)
                .text('Happiness');

            // precip on the x-axis
            let bottomAxis = d3.axisBottom(precipScale)
                .ticks(10, "~g");
            svg.append('g')
                .attr('class', 'x axis')
                .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                .call(bottomAxis);

            svg.append('text')
                .attr('class', 'bottom axis label')
                .attr('transform', `translate(${chartWidth / 2 - margins.left + 20},${chartHeight + margins.top + 45})`)
                .text('Logarithmic Mean Precipitation Hours');

            // left gridlines
            let leftGridlines = d3.axisLeft(happinessScale)
                .tickSize(-chartWidth - 10)
                .tickFormat('');
            svg.append('g')
                .attr('class', 'y gridlines')
                .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                .call(leftGridlines);

            // bottom gridlines
            let bottomGridlines = d3.axisBottom(precipScale)
                .tickSize(-chartHeight - 10)
                .tickFormat('');
            svg.append('g')
                .attr('class', 'x gridlines')
                .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                .call(bottomGridlines);


            // group points by region for background blobs
            const groupedData = d3.groups(data, d => d.region);
            console.log('grouped data: ');
            console.log(groupedData);

            // line generator to draw the path of the blobs and draw curves
            const lineGen = d3.line()
                .curve(d3.curveMonotoneX);

            // for each region, compute the convex hull and draw a path (blob)
            groupedData.forEach(([region, points]) => {
                const hull = d3.polygonHull(points.map(d => [precipScale(d['precipitation_hours_mean']), happinessScale(d['happiness'])]));

                if (hull) {
                    chartArea.append('path')
                        .attr('d', lineGen(hull))
                        .attr('fill', colorScale(region))
                        .attr('opacity', 0.2)  // make the blobs lighter than the circles
                        .attr('stroke', colorScale(region))
                        .attr('stroke-width', 1);
                }
            });

            // adding the points
            let circles = chartArea.selectAll("circle").data(data)
                .join("circle")
                .attr("r", 6)
                .attr('opacity', 0.4)
                .attr("fill", d => colorScale(d.region))  // color by region
                .attr("region", d => d.region)
                .attr("city", d => d.city)
                .attr("precip", d => d['precipitation_hours_mean'])
                .attr("cx", d => precipScale(d['precipitation_hours_mean']))
                .attr("cy", d => happinessScale(d['happiness']));

            // creating the legend
            var legend = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${chartWidth + margins.left + 20}, ${margins.top})`);

            let regionsArr = ["West", "Midwest", "Southwest", "Southeast", "Northeast"];

            // creates the space for the rectangles in legend
            let rectSpaces = legend.selectAll(".legend-key")
                .data(regionsArr)
                .enter()
                .append('g')
                .attr('class', 'legend-key')
                .attr('transform', (elem, i) => `translate(0, ${i * 25})`);

            // Append rectangles to each legend entry
            rectSpaces.append('rect')
                .attr('height', 20)
                .attr('width', 20)
                .attr('opacity', 0.4)
                .attr('fill', d => colorScale(d));

            // Append text labels for each legend entry
            rectSpaces.append('text')
                .attr('x', 30)
                .attr('y', 15)
                .text(d => d);


            // make the points OVER the gridlines
            chartArea.raise();

        });
    </script>
    <svg id="titleSvg3" height=100 width=1000>
    </svg>
    <svg id="scatterplot3" height=500 width=1000>
    </svg>
    <script>
        titleSvg3 = d3.select('svg#titleSvg3');
        titleSvg3.append('text')
            .attr('x', 450)
            .attr('y', 40)
            .attr('text-anchor', 'middle')
            .style('font-size', '24px')
            .style('font-weight', 'bold')
            .text('Happiness vs Precipitation Amount');

        // add the caption
        titleSvg3.append('text')
            .attr('x', 400)
            .attr('y', 80)
            .attr('text-anchor', 'middle')
            .style('font-size', '14px')
            .text(`Graph 3: Happiness of USA cities with respect to the 
            logarithmic average precipitation in inches a city experiences 
            per day.`);
        d3.csv("happiness.csv").then((data) => {
            data.forEach((d, i) => {
                d['happiness'] = Number(d['happiness']);
                d['precipitation_sum_mean'] = Number(d['precipitation_sum_mean']);
            });
            console.log("scatter plot 3: ");
            console.log(data);
            const svg = d3.select('svg#scatterplot3');
            const width = svg.attr('width');
            const height = svg.attr('height');
            const margins = { top: 10, right: 220, bottom: 70, left: 70 };
            const chartWidth = width - margins.left - margins.right;
            const chartHeight = height - margins.top - margins.bottom;
            let chartArea = svg.append('g')
                .attr('transform', `translate(${margins.left},${margins.top})`);

            const precipExtent = d3.extent(data, d => d['precipitation_sum_mean']);
            console.log("precip sum extent: ");
            console.log(precipExtent);
            const precipScale = d3.scaleLog()
                .domain(precipExtent)
                .range([0, chartWidth]);


            const happinessExtent = d3.extent(data, d => d['happiness']);
            const happinessScale = d3.scaleLinear()
                .domain(happinessExtent)
                .range([chartHeight, 0]);

            // happiness on the y-axis
            let leftAxis = d3.axisLeft(happinessScale);
            svg.append('g')
                .attr('class', 'y axis')
                .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                .call(leftAxis);

            svg.append('text')
                .attr('class', 'left axis label')
                .attr('transform', `translate(${margins.left - 45},${chartHeight / 2 + margins.top + 20}) rotate(${-90})`)
                .text('Happiness');

            // precip on the x-axis
            let bottomAxis = d3.axisBottom(precipScale)
                .ticks(10, "~g");
            svg.append('g')
                .attr('class', 'x axis')
                .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                .call(bottomAxis);

            svg.append('text')
                .attr('class', 'bottom axis label')
                .attr('transform', `translate(${chartWidth / 2 - margins.left},${chartHeight + margins.top + 45})`)
                .text('Logarithmic Mean Precipitation Sum (Inches)');

            // left gridlines
            let leftGridlines = d3.axisLeft(happinessScale)
                .tickSize(-chartWidth - 10)
                .tickFormat('');
            svg.append('g')
                .attr('class', 'y gridlines')
                .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                .call(leftGridlines);

            // bottom gridlines
            let bottomGridlines = d3.axisBottom(precipScale)
                .tickSize(-chartHeight - 10)
                .tickFormat('');
            svg.append('g')
                .attr('class', 'x gridlines')
                .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                .call(bottomGridlines);

            // group points by region for background blobs
            const groupedData = d3.groups(data, d => d.region);
            console.log('grouped data: ');
            console.log(groupedData);

            // line generator to draw the path of the blobs and draw curves
            const lineGen = d3.line()
                .curve(d3.curveMonotoneX);

            // for each region, compute the convex hull and draw a path (blob)
            groupedData.forEach(([region, points]) => {
                const hull = d3.polygonHull(points.map(d => [precipScale(d['precipitation_sum_mean']), happinessScale(d['happiness'])]));

                if (hull) {
                    chartArea.append('path')
                        .attr('d', lineGen(hull))
                        .attr('fill', colorScale(region))
                        .attr('opacity', 0.2)  // make the blobs lighter than the circles
                        .attr('stroke', colorScale(region))
                        .attr('stroke-width', 1);
                }
            });


            // adding the points
            let circles = chartArea.selectAll("circle").data(data)
                .join("circle")
                .attr("r", 6)
                .attr('opacity', 0.4)
                .attr("fill", d => colorScale(d.region))  // color by region
                .attr("region", d => d.region)
                .attr("city", d => d.city)
                .attr("precip_sum", d => d['precipitation_sum_mean'])
                .attr("cx", d => precipScale(d['precipitation_sum_mean']))
                .attr("cy", d => happinessScale(d['happiness']));

            // creating the legend
            var legend = svg.append('g')
                .attr('class', 'legend')
                .attr('transform', `translate(${chartWidth + margins.left + 20}, ${margins.top})`);

            let regionsArr = ["West", "Midwest", "Southwest", "Southeast", "Northeast"];

            // creates the space for the rectangles in legend
            let rectSpaces = legend.selectAll(".legend-key")
                .data(regionsArr)
                .enter()
                .append('g')
                .attr('class', 'legend-key')
                .attr('transform', (elem, i) => `translate(0, ${i * 25})`);

            // Append rectangles to each legend entry
            rectSpaces.append('rect')
                .attr('height', 20)
                .attr('width', 20)
                .attr('opacity', 0.4)
                .attr('fill', d => colorScale(d));

            // Append text labels for each legend entry
            rectSpaces.append('text')
                .attr('x', 30)
                .attr('y', 15)
                .text(d => d);


            // make the points OVER the gridlines
            chartArea.raise();

        });
    </script>

    <h3>Graph: Visualizing Parallel Coordinates of Happiness and Climate Data</h3>
    <p>This D3 code creates a parallel coordinates plot visualizing dimensions like happiness and climate data, to see
        how different factors like temperature, rain, and income levels correlate with happiness. </p>

    <svg id="parallelPlot" width="1000" height="500"></svg>
    <div id="tooltip" class="tooltip"></div>

    <script>
        const margin = { top: 50, right: 30, bottom: 30, left: 100 },
            width = 1000 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;

        const svg = d3.select("#parallelPlot")
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const tooltip = d3.select("#tooltip");

        d3.csv("happiness.csv").then((data) => {
            const dimensions = ["happiness", "max_temp_mean", "rain_sum_mean", "income_employment_rank"];

            const y = {};
            dimensions.forEach(dim => {
                if (dim === "rain_sum_mean") {
                    y[dim] = d3.scaleLinear()
                        .domain(d3.extent(data, d => +d[dim]))
                        .range([0, height]);
                } else {
                    y[dim] = d3.scaleLinear()
                        .domain(d3.extent(data, d => +d[dim]))
                        .range([height, 0]);
                }
            });

            const x = d3.scalePoint()
                .range([0, width])
                .padding(1)
                .domain(dimensions);

            function path(d) {
                return d3.line()(dimensions.map(p => [x(p), y[p](+d[p])]));
            }

            svg.selectAll("myPath")
                .data(data)
                .enter().append("path")
                .attr("class", "line")
                .attr("d", path)
                .on("mouseover", (event, d) => {
                    d3.select(event.currentTarget).style("stroke", "orange").style("opacity", 1);
                    tooltip
                        .style("opacity", 1)
                        .html(`City: ${d.city}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY + 10) + "px");
                })
                .on("mousemove", (event) => {
                    tooltip
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY + 10) + "px");
                })
                .on("mouseout", (event, d) => {
                    d3.select(event.currentTarget).style("stroke", "steelblue").style("opacity", 0.5);
                    tooltip.style("opacity", 0);
                });

            svg.selectAll("myAxis")
                .data(dimensions).enter()
                .append("g")
                .attr("transform", d => `translate(${x(d)})`)
                .each(function (d) { d3.select(this).call(d3.axisLeft().scale(y[d])); })
                .append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(d => d)
                .style("fill", "black");
        });

        // Citation: I referred to the Mozilla Developers Network (MDN) Mouse Events Documentation, and additional insights for creating parallel coordinates plots were obtained from the D3 Graph Gallery. Source: https://d3-graph-gallery.com/parallel 

    </script>
</body>

</html>