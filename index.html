<html>

<head>
    <meta charset="UTF-8">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
        .gridlines line {
            stroke: #bbb;
        }

        .gridlines .domain {
            stroke: none;
        }

        .county {
            fill: lightgrey;
        }

        .outline {
            fill: none;
            stroke: black;
            stroke-width: 1px;
        }

        .graticule {
            fill: none;
            stroke: grey;
            stroke-width: 1px;
        }

        .axis path,
        .axis line {
            fill: none;
            shape-rendering: crispEdges;
        }

        .axis text {
            font-size: 12px;
        }

        .line {
            fill: none;
            stroke-width: 1.5px;
            opacity: 0.5;
        }

        .tooltip {
            opacity: 0;
            position: absolute;
            background-color: white;
            border: solid 1px;
            padding: 10px;
            pointer-events: none;
            z-index: 10;
        }

        .flex-container {
            display: flex;
        }

        .padding {
            margin-left: 5;
            margin-right: 5;
        }
    </style>
</head>

<body>
    <h1>Happiness v.s. Weather Variables in the US :)</h1>
    <h2>How does sunlight affect happiness?</h2>
    <div class="flex-container padding">
        <div>
            <p>
                This graph shows the happiness values of various cities in the US, with larger and darker circles
                indicating
                greater happiness. The circles are placed over a map which shows the average sunlight intensity for each
                county
                in the US.
                We want to visualize whether sunlight correlates with the happiness of a region.
            </p>
            <svg id="sunlight_map" height=500 width=800></svg>
            <svg id="sunlight_map_legend" height="100" width="600"
                style="background: #fff; margin-top:30px; padding-bottom:50px"></svg>
        </div>
        <div>
            <p>
                Happiness of USA cities with respect to the intensity of sunlight a city gets per day. Each circle
                represents a city in the USA,
                sorted into regions by color.
            </p>
            <svg id="sunlight_scatterplot" height=500 width=900 style="margin-bottom: 50px;"></svg>
        </div>
    </div>

    <h2>How does temperature affect happiness?</h2>
    <div class="flex-container padding">
        <div>
            <p>
                This graph shows the happiness values of various cities in the US, with larger and darker circles
                indicating
                greater happiness. The circles are placed over a map which shows the average temperature for each
                county
                in the US.
            </p>
            <svg id="temp_map" height=500 width=800></svg>
            <svg id="temp_map_legend" height="100" width="600"
                style="background: #fff; margin-top:30px; padding-bottom:50px"></svg>
        </div>
        <div>
            <p>
                Happiness of USA cities with respect to the average temperature a city gets per day. Each circle
                represents a
                city in the USA,
                sorted into regions by color.
            </p>
            <svg id="temp_scatterplot" height=500 width=900 style="margin-bottom: 50px;"></svg>
        </div>
    </div>

    <h2>How does precipitation affect happiness?</h2>
    <div class="flex-container padding">
        <div>
            <p>
                This graph shows the happiness values of various cities in the US, with larger and darker circles
                indicating
                greater happiness. The circles are placed over a map which shows the average precipitation for each
                county
                in the US.
            </p>
            <svg id="precip_map" height=500 width=800></svg>
            <svg id="precip_map_legend" height="100" width="600"
                style="background: #fff; margin-top:30px; padding-bottom:50px"></svg>
        </div>
        <div>
            <p>
                Happiness of USA cities with respect to the logarithmic average precipitation in inches a city
                experiences per
                day. Each circle represents a city in the USA,
                sorted into regions by color.
            </p>
            <svg id="precip_scatterplot" height=500 width=900 style="margin-bottom: 50px;"></svg>
        </div>
    </div>

    <h2>Visualizing Parallel Coordinates of Happiness and Climate Data</h2>
    <p>This parallel coordinates plot visualizes dimensions like happiness and climate data, to see
        how different factors like temperature, rain, and income levels correlate with happiness. </p>

    <svg id="parallelPlot" width="1000" height="500"></svg>
    <div id="tooltip" class="tooltip"></div>

    <script>
        // Code below adapted from October 7 class notes
        const requestData = async function () {
            let countiesDataset = await d3.json("counties-10m.json");

            const countyWeatherData = await d3.csv("county_weather_data.csv");

            var countyDict = {}   // countyID ===> countyData
            countyWeatherData.forEach(d => {
                countyDict[d["County Code"]] = d;
            });

            const data = await d3.csv("happiness.csv", d3.autoType);

            makeMap("sunlight_map", "Avg Daily Sunlight (MJ/m)", "#sunlight_map_legend", "Average Daily Sunlight (MJ/m²)")
            makeMap("temp_map", "Avg Temp", "#temp_map_legend", "Avg Daily Temp (°F)")
            makeMap("precip_map", "Avg Daily Precipitation (in)", "#precip_map_legend", "Avg Daily Precipitation (in)")

            function makeMap(select, weatherVar, legendSelect, legendText) {
                const svg = d3.select(`svg#${select}`);
                const width = svg.attr('width');
                const height = svg.attr('height');
                const margins = { top: 20, right: 20, bottom: 20, left: 20 };
                const mapWidth = width - margins.left - margins.right;
                const mapHeight = height - margins.top - margins.bottom;

                let mapArea = svg.append('g')
                    .attr('transform', `translate(${margins.left},${margins.top})`);

                // Pick out topographic features and build d3 helpers
                var counties = topojson.feature(countiesDataset, countiesDataset.objects.counties);
                var countiesMesh = topojson.mesh(countiesDataset, countiesDataset.objects.counties);
                var projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], counties);
                var path = d3.geoPath().projection(projection);

                // Add a graticule
                let graticule = d3.geoGraticule10();
                mapArea.append("path").attr("class", "graticule").attr("d", path(graticule));

                // Draw counties and outlines
                let countyPaths = mapArea.selectAll("path.county").data(counties.features)
                    .join("path")
                    .attr("class", "county")
                    .attr("d", path)

                mapArea.append("path").datum(countiesMesh)
                    .attr("class", "outline")
                    .attr("d", path);

                const happinessExtent = d3.extent(data, d => d["happiness"]);
                const happinessScale = d3.scaleLinear().domain(happinessExtent)
                    .range([0, 15]);

                const happinessColorScale = d3.scaleSequential(d3.interpolateGnBu).domain(happinessExtent);

                // Add the happiness circles
                mapArea.selectAll("circle").data(data)
                    .join("circle")
                    .attr("cx", d => projection([d["longitude"], d["latitude"]])[0])
                    .attr("cy", d => projection([d["longitude"], d["latitude"]])[1])
                    .attr("r", d => happinessScale(d["happiness"]))
                    .style("fill", d => happinessColorScale(d["happiness"]))
                    .style("stroke", "white")

                // Make a color scale for weather vars    
                const weatherVarExtent = d3.extent(countyWeatherData, d => d[weatherVar]);

                const weatherVarScale = d3.scaleQuantile()
                    .domain(d3.map(countyWeatherData, d => d[weatherVar]))
                    .range(["#e8ecfa", "#62a1db", "#e7d87d", "#dd9f40", "#b4451f", "#b01111"]);

                // Recolor the counties to make a choropleth map
                mapArea.selectAll(".county")
                    .style("fill", d => weatherVarScale(countyDict[d.id] === undefined ? 0 : countyDict[d.id][weatherVar]));

                // Hiding Alaska and Hawaii
                mapArea.append("rect")
                    .attr('x', -10)
                    .attr('y', 342)
                    .attr('width', 240)
                    .attr('height', 150)
                    .attr('fill', '#fff');
                
                mapArea.append("rect")
                    .attr('x', -10)
                    .attr('y', 390)
                    .attr('width', 310)
                    .attr('height', 150)
                    .attr('fill', '#fff');

                // Use Prof. Rz's legend code to draw a legend
                // Flexible legend-drawing function - Jeff Rzeszotarski, 2022
                // Released under MIT Free license
                drawLegend(legendSelect, weatherVarScale, legendText);
            }
        }
        requestData();
    </script>

    <script>
        let colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        d3.csv("happiness.csv").then((data) => {
            data.forEach((d, i) => {
                d['happiness'] = Number(d['happiness']);
                d['sunshine_duration_mean'] = Number(d['sunshine_duration_mean']);
                d['precipitation_hours_mean'] = Number(d['precipitation_hours_mean']);
                d['shortwave_radiation_sum_mean'] = Number(d['shortwave_radiation_sum_mean']);
            });

            makeScatterplot('sunlight_scatterplot', 'shortwave_radiation_sum_mean', 'lin', 'Average Daily Sunlight (MJ/m²)')
            makeScatterplot('temp_scatterplot', 'avg_temp_mean', 'lin', 'Mean Temperature (°F)')
            makeScatterplot('precip_scatterplot', 'precipitation_sum_mean', 'log', 'Mean Precipitation (in)')

            function makeScatterplot(selector, varName, scale, bottomText) {
                const svg = d3.select(`svg#${selector}`);
                const width = svg.attr('width');
                const height = svg.attr('height');
                const margins = { top: 10, right: 220, bottom: 70, left: 70 };
                const chartWidth = width - margins.left - margins.right;
                const chartHeight = height - margins.top - margins.bottom;
                let chartArea = svg.append('g')
                    .attr('transform', `translate(${margins.left},${margins.top})`);

                const varExtent = d3.extent(data, d => d[varName]);

                var varScale = undefined
                if (scale === "lin") {
                    varScale = d3.scaleLinear()
                } else if (varScale = "log") {
                    varScale = d3.scaleLog()
                }
                varScale
                    .domain(varExtent)
                    .range([0, chartWidth]);

                const happinessExtent = d3.extent(data, d => d['happiness']);
                const happinessScale = d3.scaleLinear()
                    .domain(happinessExtent)
                    .range([chartHeight, 0]);

                // happiness on the y-axis
                let leftAxis = d3.axisLeft(happinessScale);
                svg.append('g')
                    .attr('class', 'y axis')
                    .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                    .call(leftAxis);

                svg.append('text')
                    .attr('class', 'left axis label')
                    .attr('transform', `translate(${margins.left - 45},${chartHeight / 2 + margins.top + 20}) rotate(${-90})`)
                    .text('Happiness');

                // sunshine on the x-axis
                let bottomAxis = d3.axisBottom(varScale)
                    .ticks(10, "~g");
                svg.append('g')
                    .attr('class', 'x axis')
                    .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                    .call(bottomAxis);


                svg.append('text')
                    .attr('class', 'bottom axis label')
                    .attr('transform', `translate(${chartWidth / 2 - margins.left + 15},${chartHeight + margins.top + 45})`)
                    .text(bottomText);

                // left gridlines
                let leftGridlines = d3.axisLeft(happinessScale)
                    .tickSize(-chartWidth - 10)
                    .tickFormat('');
                svg.append('g')
                    .attr('class', 'y gridlines')
                    .attr('transform', `translate(${margins.left - 10},${margins.top})`)
                    .call(leftGridlines);

                // bottom gridlines
                let bottomGridlines = d3.axisBottom(varScale)
                    .tickSize(-chartHeight - 10)
                    .tickFormat('');


                svg.append('g')
                    .attr('class', 'x gridlines')
                    .attr('transform', `translate(${margins.left},${chartHeight + margins.top + 10})`)
                    .call(bottomGridlines);

                // group points by region for background blobs
                const groupedData = d3.groups(data, d => d.region);

                // line generator to draw the path of the blobs and draw curves
                const lineGen = d3.line()
                    .curve(d3.curveMonotoneX);

                // for each region, compute the convex hull and draw a path (blob)
                groupedData.forEach(([region, points]) => {
                    const hull = d3.polygonHull(points.map(d => [varScale(d[varName]), happinessScale(d['happiness'])]));

                    if (hull) {
                        chartArea.append('path')
                            .attr('d', lineGen(hull))
                            .attr('fill', colorScale(region))
                            .attr('opacity', 0.2)  // make the blobs lighter than the circles
                            .attr('stroke', colorScale(region))
                            .attr('stroke-width', 1);
                    }
                });

                // adding the points
                let circles = chartArea.selectAll("circle").data(data)
                    .join("circle")
                    .attr("r", 6)
                    .attr('opacity', 0.4)
                    .attr("fill", d => colorScale(d.region))  // color by region
                    .attr("region", d => d.region)
                    .attr("cx", d => varScale(d[varName]))
                    .attr("cy", d => happinessScale(d['happiness']));

                // creating the legend
                var legend = svg.append('g')
                    .attr('class', 'legend')
                    .attr('transform', `translate(${chartWidth + margins.left + 20}, ${margins.top})`);

                let regionsArr = ["West", "Midwest", "Southwest", "Southeast", "Northeast"];

                // creates the space for the rectangles in legend
                let rectSpaces = legend.selectAll(".legend-key")
                    .data(regionsArr)
                    .enter()
                    .append('g')
                    .attr('class', 'legend-key')
                    .attr('transform', (elem, i) => `translate(0, ${i * 25})`);

                // Append rectangles to each legend entry
                rectSpaces.append('rect')
                    .attr('height', 20)
                    .attr('width', 20)
                    .attr('opacity', 0.4)
                    .attr('fill', d => colorScale(d));

                // Append text labels for each legend entry
                rectSpaces.append('text')
                    .attr('x', 30)
                    .attr('y', 15)
                    .text(d => d);


                // make the points OVER the gridlines
                chartArea.raise();
            }
        });
    </script>

    <script>
        const margin = { top: 50, right: 100, bottom: 30, left: 100 },
            width = 1000 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;

        const svg = d3.select("#parallelPlot")
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const tooltip = d3.select("#tooltip");

        d3.csv("happiness.csv").then((data) => {
            const dimensions = ["happiness", "max_temp_mean", "rain_sum_mean", "income_employment_rank"];

            const regions = d3.groups(data, d => d.region);

            const topCities = regions.flatMap(([region, cities]) => {
                return cities
                    .sort((a, b) => d3.descending(+a.happiness, +b.happiness))
                    .slice(0, 2);
            });

            const colorScale = d3.scaleOrdinal(d3.schemeCategory10)
                .domain([...new Set(topCities.map(d => d.region))]);

            const y = {};
            dimensions.forEach(dim => {
                if (dim === "rain_sum_mean") {
                    y[dim] = d3.scaleLinear()
                        .domain(d3.extent(topCities, d => +d[dim]))
                        .range([0, height]);
                } else {
                    y[dim] = d3.scaleLinear()
                        .domain(d3.extent(topCities, d => +d[dim]))
                        .range([height, 0]);
                }
            });

            const x = d3.scalePoint()
                .range([0, width])
                .padding(1)
                .domain(dimensions);

            function path(d) {
                return d3.line()(dimensions.map(p => [x(p), y[p](+d[p])]));
            }

            svg.selectAll("myPath")
                .data(topCities)
                .enter().append("path")
                .attr("class", "line")
                .attr("d", path)
                .style("stroke", d => colorScale(d.region))
                .on("mouseover", (event, d) => {
                    d3.select(event.currentTarget).style("stroke", "orange").style("opacity", 1);
                    tooltip
                        .style("opacity", 1)
                        .html(`City: ${d.city}<br>Region: ${d.region}`)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY + 10) + "px");
                })
                .on("mousemove", (event) => {
                    tooltip
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY + 10) + "px");
                })
                .on("mouseout", (event, d) => {
                    d3.select(event.currentTarget).style("stroke", colorScale(d.region)).style("opacity", 0.5);
                    tooltip.style("opacity", 0);
                });

            svg.selectAll("myAxis")
                .data(dimensions).enter()
                .append("g")
                .attr("transform", d => `translate(${x(d)})`)
                .each(function (d) { d3.select(this).call(d3.axisLeft().scale(y[d])); })
                .append("text")
                .style("text-anchor", "middle")
                .attr("y", -9)
                .text(d => d)
                .style("fill", "black");

            const legend = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width + 20}, 20)`);

            const legendRegions = [...new Set(topCities.map(d => d.region))];

            legend.selectAll("legendDots")
                .data(legendRegions)
                .enter()
                .append("rect")
                .attr("x", 0)
                .attr("y", (d, i) => i * 25)
                .attr("width", 18)
                .attr("height", 18)
                .style("fill", d => colorScale(d));

            legend.selectAll("legendLabels")
                .data(legendRegions)
                .enter()
                .append("text")
                .attr("x", 25)
                .attr("y", (d, i) => i * 25 + 13)
                .text(d => d)
                .style("fill", "black")
                .style("font-size", "12px");
        });
        // Citation:  I referred to the Mozilla Developers Network (MDN) Mouse Events Documentation, and additional insights for creating parallel coordinates plots were obtained from the D3 Graph Gallery. Source: https://d3-graph-gallery.com/parallel, https://jonathansoma.com/lede/storytelling/d3/grouping-and-nesting/, https://observablehq.com/@sandraviz/d3-hierarchal-data
    </script>

    <script>
        // Flexible legend-drawing function - Jeff Rzeszotarski, 2022
        //   Released under MIT Free license
        //  Takes in an SVG element selector <legendSelector> and a d3 color scale <legendColorScale>
        //
        // Usage example: drawLegend("#legendID", grossIncomeColorScale)
        function drawLegend(legendSelector, legendColorScale, legendText) {

            // This code should adapt to a variety of different kinds of color scales
            //  Credit Prof. Rz if you are basing a legend on this structure, and note PERFORMANCE CONSIDERATIONS

            // Shrink legend bar by 5 px inwards from sides of SVG
            const offsets = {
                width: 10,
                top: 2,
                bottom: 24
            };
            // Number of integer 'pixel steps' to draw when showing continuous scales
            //    Warning, not using a canvas element so lots of rect tags will be created for low stepSize, causing issues with performance -- keep this large
            const stepSize = 4;
            // Extend the minmax by 0% in either direction to expose more features by default
            const minMaxExtendPercent = 0;


            const legend = d3.select(legendSelector);
            const legendHeight = legend.attr("height");
            const legendBarWidth = legend.attr("width") - (offsets.width * 2);
            const legendMinMax = d3.extent(legendColorScale.domain());
            // recover the min and max values from most kinds of numeric scales
            const minMaxExtension = (legendMinMax[1] - legendMinMax[0]) * minMaxExtendPercent;
            const barHeight = legendHeight - offsets.top - offsets.bottom;

            // In this case the "data" are pixels, and we get numbers to use in colorScale
            // Use this to make axis labels
            let barScale = d3.scaleLinear().domain([legendMinMax[0] - minMaxExtension,
            legendMinMax[1] + minMaxExtension])
                .range([0, legendBarWidth]);
            let barAxis = d3.axisBottom(barScale);

            // Place for bar slices to live
            let bar = legend.append("g")
                .attr("class", "legend colorbar")
                .attr("transform", `translate(${offsets.width},${offsets.top})`)

            // ****** SWITCHES FOR DIFFERENT SCALE TYPES ******

            // Check if we're using a binning scale - if so, we make blocks of color
            if (legendColorScale.hasOwnProperty('thresholds') || legendColorScale.hasOwnProperty('quantiles')) {
                // Get the thresholds
                let thresholds = [];
                if (legendColorScale.hasOwnProperty('thresholds')) { thresholds = legendColorScale.thresholds() }
                else { thresholds = legendColorScale.quantiles() }

                const barThresholds = [legendMinMax[0], ...thresholds, legendMinMax[1]];

                // Use the quantile breakpoints plus the min and max of the scale as tick values
                barAxis.tickValues(barThresholds);

                // Draw rectangles between the threshold segments
                for (let i = 0; i < barThresholds.length - 1; i++) {
                    let dataStart = barThresholds[i];
                    let dataEnd = barThresholds[i + 1];
                    let pixelStart = barAxis.scale()(dataStart);
                    let pixelEnd = barAxis.scale()(dataEnd);

                    bar.append("rect")
                        .attr("x", pixelStart)
                        .attr("y", 0)
                        .attr("width", pixelEnd - pixelStart)
                        .attr("height", barHeight)
                        .style("fill", legendColorScale((dataStart + dataEnd) / 2.0))
                        .style("stroke", "black");
                }
            }
            // Else if we have a continuous / roundable scale
            //  In an ideal world you might construct a custom gradient mapped to the scale
            //  For this one, we use a hack of making stepped rects
            else if (legendColorScale.hasOwnProperty('rangeRound')) {
                // NOTE: The barAxis may round min and max values to make them pretty
                // ** This also means there is a risk of the legend going beyond scale bounds
                // We need to use the barAxis min and max just to be sure the bar is complete
                //    Using barAxis.scale().invert() goes from *axis* pixels to data values easily
                // ** We also need to create patches for the scale if the labels exceed bounds
                //     (floating point comparisons risky for small data ranges,but not a big deal
                //      because patches will be indistinguishable from actual scale bottom)
                // It's likely that scale clamping will actually do this for us elegantly
                // ...but better to be safer and patch the regions anyways

                for (let i = 0; i < legendBarWidth; i = i + stepSize) {

                    let center = i + (stepSize / 2);
                    let dataCenter = barAxis.scale().invert(center);

                    // below normal scale bounds
                    if (dataCenter < legendMinMax[0]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[0]))
                            .style("stroke", "black");
                    }
                    // within normal scale bounds
                    else if (dataCenter < legendMinMax[1]) {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(dataCenter))
                            .style("stroke", "black");
                    }
                    // above normal scale bounds
                    else {
                        bar.append("rect")
                            .attr("x", i)
                            .attr("y", 0)
                            .attr("width", stepSize)
                            .attr("height", barHeight)
                            .style("fill", legendColorScale(legendMinMax[1]))
                            .style("stroke", "black");
                    }

                }
            }
            // Otherwise we have a nominal scale
            else {
                let nomVals = legendColorScale.domain().sort();

                // Use a scaleBand to make blocks of color and simple labels
                let barScale = d3.scaleBand().domain(nomVals)
                    .range([0, legendBarWidth])
                    .padding(0.05);
                barAxis.scale(barScale);

                // Draw rectangles for each nominal entry
                nomVals.forEach(d => {
                    bar.append("rect")
                        .attr("x", barScale(d))
                        .attr("y", 0)
                        .attr("width", barScale.bandwidth())
                        .attr("height", barHeight)
                        .style("fill", legendColorScale(d))
                        .style("stroke", "black");
                });
            }
            // DONE w/SWITCH

            // Finally, draw legend labels
            legend.append("g")
                .attr("class", "legend axis")
                .attr("transform", `translate(${offsets.width},${offsets.top + barHeight + 5})`)
                .call(barAxis);

            legend.append("text").text(legendText)
                .attr("transform", `translate(${legendBarWidth / 2 - 75},${120})`)
            // .style("text-align", "center")
            // .style("margin", "auto")

        }
    </script>
</body>

</html>